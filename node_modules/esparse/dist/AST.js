'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _Nodes = require('./Nodes.js');

Object.keys(_Nodes).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _Nodes[key];
    }
  });
});

var Nodes = _interopRequireWildcard(_Nodes);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/*

NOTE: We forego using classes and class-based inheritance because at this time
super() tends to be slow in transpiled code.  Instead, we use regular constructor
functions and give them a common prototype property.

*/
function isNode(x) {
  return x !== null && typeof x === 'object' && typeof x.type === 'string';
}

class AstNode {

  children() {
    let keys = Object.keys(this);
    let list = [];

    for (let i = 0; i < keys.length; ++i) {
      if (keys[i] === 'parent') continue;

      let value = this[keys[i]];

      if (Array.isArray(value)) {

        for (let j = 0; j < value.length; ++j) {
          if (isNode(value[j])) list.push(value[j]);
        }
      } else if (isNode(value)) {

        list.push(value);
      }
    }

    return list;
  }

}

Object.keys(Nodes).forEach(k => Nodes[k].prototype = AstNode.prototype);